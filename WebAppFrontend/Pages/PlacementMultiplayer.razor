@page "/multiplayerPlacement/{RoomId}/{PlayerId}/{GridSize:int}"
@using Microsoft.AspNetCore.SignalR.Client
@inject NavigationManager Navigation

<div class="container mt-4">
    <h2 class="text-center">Multiplayer: Place Your Ships</h2>
    
    @if (_isWaiting)
    {
        <div class="alert alert-warning text-center">
            <h4>Ships Placed!</h4>
            <p>Waiting for your opponent to finish placement...</p>
            <div class="spinner-border text-primary" role="status"></div>
        </div>
    }
    else
    {
        <p class="text-center">Arranging ships for Room: <strong>@RoomId</strong></p>
        <p class="text-center text-muted">Click to rotate, Drag to move.</p>

        <div class="d-flex justify-content-center">
            <div style="position: relative;">
                
                <div @onmousemove="e => Drag(e)" 
                     @onmouseup="e => EndDrag()" 
                     style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; 
                            pointer-events: @(_isDragging ? "auto" : "none"); z-index: 100;">
                </div>

                <div class="d-flex">
                    <div class="d-flex flex-column" 
                         style="width: 35px; height: @(GridPixelSize)px; justify-content: space-around;
                                text-align: center; font-weight: bold; margin-top: 35px;">
                        @for (int r = 0; r < GridSize; r++)
                        {
                            <div style="height: 35px; display: flex; align-items: center; justify-content: center;">
                                @((char)('A' + r))
                            </div>
                        }
                    </div>
                    
                    <div class="d-flex flex-column">
                        <div class="d-flex" style="width: @(GridPixelSize)px; height: 35px; justify-content: space-around; text-align: center; font-weight: bold;">
                            @for (int c = 0; c < GridSize; c++)
                            {
                                <div style="width: 35px; display: flex; align-items: center; justify-content: center;">
                                    @(c + 1)
                                </div>
                            }
                        </div>

                        <div class="player-grid-container" style="width: @(GridPixelSize)px; height: @(GridPixelSize)px; position: relative;">
                            
                            <table class="grid player-grid">
                                @for (int r = 0; r < GridSize; r++)
                                {
                                    <tr>
                                        @for (int c = 0; c < GridSize; c++)
                                        {
                                            <td class="cell player-cell"></td>
                                        }
                                    </tr>
                                }
                            </table>

                            @foreach (var ship in _myShips)
                            {
                                var top = ship.StartRow * CellStep;
                                var left = ship.StartCol * CellStep;
                                var shipStyle = string.Empty;
                                var orientation = ship.IsHorizontal ? "horizontal" : "vertical";
                                var lengthPixels = ship.Size * CellStep;

                                if (ship.IsHorizontal)
                                {
                                    shipStyle = $"top: {top}px; left: {left}px; width: {lengthPixels}px; height: {CellStep}px;";
                                }
                                else
                                {
                                    shipStyle = $"top: {top}px; left: {left}px; width: {CellStep}px; height: {lengthPixels}px;";
                                }
                                
                                <div class="ship-overlay"
                                     @key="ship.Symbol"
                                     style="@shipStyle"
                                     @onmousedown="e => StartDrag(e, ship)">
                                     <img src="@($"./images/Length{ship.Size}_{orientation}.png")" 
                                          alt="Ship @ship.Symbol"
                                          style="width: 100%; height: 100%; display: block;" 
                                          draggable="false" /> 
                                </div>
                            }
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="text-center mt-4">
            <button class="btn btn-success btn-lg" @onclick="ConfirmPlacement">
                Confirm & Ready
            </button>
        </div>
    }
</div>

@code {
    [Parameter] public required string RoomId { get; set; }
    [Parameter] public required string PlayerId { get; set; }
    [Parameter] public int GridSize { get; set; }

    private HubConnection? _hubConnection;
    private List<Ship> _myShips = new();
    
    // Constants
    private const int CellStep = 35;
    private int GridPixelSize => GridSize * CellStep;
    
    // State
    private bool _isWaiting;

    // Dragging Logic Variables
    private Ship? _activeShip;
    private bool _isDragging;
    private double _offsetX;
    private double _offsetY;
    private bool _hasMoved;
    private int _tempStartRow;
    private int _tempStartCol;

    protected override async Task OnInitializedAsync()
    {
        InitializeDefaultShips();

        _hubConnection = new HubConnectionBuilder()
            .WithUrl("http://localhost:5120/battleHub") // Ensure this matches your API URL
            .WithAutomaticReconnect()
            .Build();

        _hubConnection.On("WaitingForOpponent", () =>
        {
            _isWaiting = true;
            StateHasChanged();
        });

        _hubConnection.On<string>("StartBattle", (room) =>
        {
            Console.WriteLine("Starting battle!");
            Navigation.NavigateTo($"/multiplayerGame/{room}/{PlayerId}");
        });

        await _hubConnection.StartAsync();
        
        if (_hubConnection is not null)
        {
            await _hubConnection.InvokeAsync("Rejoin", RoomId, PlayerId);
        }
    }

    private void InitializeDefaultShips()
    {
        // Default ship loadout - you might want to adjust based on GridSize
        _myShips = new List<Ship>
        {
            new() { Symbol = 'A', Size = 1, StartRow = 0, StartCol = 0, IsHorizontal = true },
            new() { Symbol = 'B', Size = 2, StartRow = 2, StartCol = 0, IsHorizontal = true },
            new() { Symbol = 'C', Size = 2, StartRow = 3, StartCol = 0, IsHorizontal = true },
            new() { Symbol = 'D', Size = 3, StartRow = 6, StartCol = 0, IsHorizontal = true },
            new() { Symbol = 'E', Size = 3, StartRow = 7, StartCol = 0, IsHorizontal = true },
            new() { Symbol = 'F', Size = 4, StartRow = 9, StartCol = 0, IsHorizontal = true }
        };
    }

    // --- Drag and Drop Logic (Ported from Placement.razor) ---

    void StartDrag(MouseEventArgs e, Ship ship)
    {
        if (e.Button != 0) return;

        _isDragging = true;
        _activeShip = ship;
        _hasMoved = false;

        // Store current position for rollback
        _tempStartRow = ship.StartRow;
        _tempStartCol = ship.StartCol;

        // Calculate offset relative to the ship's current absolute position
        // This ensures the drag feels natural regardless of screen position
        var absoluteLeft = ship.StartCol * CellStep + CellStep;
        var absoluteTop = ship.StartRow * CellStep + CellStep;

        _offsetX = e.ClientX - absoluteLeft;
        _offsetY = e.ClientY - absoluteTop;
    }

    void Drag(MouseEventArgs e)
    {
        if (!_isDragging || _activeShip == null) return;
        
        _hasMoved = true;
        
        // Calculate the proposed new CSS top/left
        var newLeft = e.ClientX - _offsetX;
        var newTop = e.ClientY - _offsetY;
        
        // Convert CSS position back to 0-indexed grid coordinates
        var proposedCol = (int)Math.Round((newLeft - CellStep) / CellStep);
        var proposedRow = (int)Math.Round((newTop - CellStep) / CellStep);

        // Update the ship's coordinates live for visual feedback
        _activeShip.StartCol = proposedCol;
        _activeShip.StartRow = proposedRow;
        StateHasChanged();
    }

    void EndDrag()
    {
        if (_activeShip == null) return;

        _isDragging = false;
        
        if (!_hasMoved)
        {
            // If just a click, Rotate
            RotateShip(_activeShip);
        }
        else
        { 
            // If dragged, Validate Final Position
            if (!IsValidPlacement(_activeShip, _myShips))
            {
                // Revert to original position if invalid
                _activeShip.StartRow = _tempStartRow;
                _activeShip.StartCol = _tempStartCol;
                Console.WriteLine("Invalid placement: Ship collision or out of bounds.");
            }
        }
        
        _activeShip = null;
        _hasMoved = false;
        StateHasChanged();
    }
    
    void RotateShip(Ship ship)
    {
        ship.IsHorizontal = !ship.IsHorizontal;
        
        if (!IsValidPlacement(ship, _myShips))
        {
            ship.IsHorizontal = !ship.IsHorizontal; // Revert
            Console.WriteLine("Invalid rotation.");
        }
        StateHasChanged();
    }
    
    // --- Validation Logic ---

    bool IsValidPlacement(Ship currentShip, List<Ship> allShips)
    {
        // 1. Boundary check using GridSize parameter
        if (currentShip.IsHorizontal)
        {
            if (currentShip.StartCol < 0 || currentShip.StartCol + currentShip.Size > GridSize || 
                currentShip.StartRow < 0 || currentShip.StartRow >= GridSize)
            {
                return false;
            }
        }
        else
        {
            if (currentShip.StartRow < 0 || currentShip.StartRow + currentShip.Size > GridSize || 
                currentShip.StartCol < 0 || currentShip.StartCol >= GridSize)
            {
                return false;
            }
        }
        
        // 2. Collision check
        foreach (var ship in allShips)
        {
            if (ship == currentShip) continue; 
            
            for (int i = 0; i < currentShip.Size; i++)
            {
                int r = currentShip.IsHorizontal ? currentShip.StartRow : currentShip.StartRow + i;
                int c = currentShip.IsHorizontal ? currentShip.StartCol + i : currentShip.StartCol;
                
                if (IsCoordinateOccupiedByShip(ship, r, c))
                {
                    return false;
                }
            }
        }
        
        return true;
    }

    bool IsCoordinateOccupiedByShip(Ship ship, int r, int c)
    {
        if (ship.IsHorizontal)
        {
            return r == ship.StartRow && c >= ship.StartCol && c < ship.StartCol + ship.Size;
        }
        else
        {
            return c == ship.StartCol && r >= ship.StartRow && r < ship.StartRow + ship.Size;
        }
    }

    private async Task ConfirmPlacement()
    {
        // Final Validation before sending to server
        foreach(var ship in _myShips)
        {
            if(!IsValidPlacement(ship, _myShips)) 
            {
                Console.WriteLine("Cannot confirm: Invalid Ship Placement");
                return; 
            }
        }

        if (_hubConnection is not null)
        {
            await _hubConnection.InvokeAsync("SubmitShips", RoomId, PlayerId, _myShips);
        }
    }
}